# Week 3 Walkthrough

_Leo Tsui 供稿_

_Leo Tsui 整理_

拼写检查器是现代文字、文本编辑应用程序常见的内置功能，应用程序在检测到用户输入的单词出现拼写错误的时候，会通过下环线标红等形式提示用户。本次作业要求实现一个拼写检查器的基本功能，分为 Hash table 和 Trie 两个版本。

**在做本次作业前必须反复仔细观看对应的授课视频。**

官方的Walkthrough提供的讲解，本文不再重复。

## Speller(Hash table)

题目一共给出了三个`.C`文件：`dictionary.c`、`dictionary.h`和`speller.c`。

主要需要完成编写的是`dictionary.c`中的几个函数`laod`、`size`、`check`、`unload`。对应着哈希表的构建、查找、和删除。

* `load`：题目已经给出了哈希表的构建等基础操作，需要完成的工作就是，从文件中依次读取字符，写入哈希表，
* `size`：可以设计一个全局变量，在`load()`阶段就统计单词的数量，`size()`函数只需要简单的返回统计出来的字典大小即可。
* `check`：在进行大小写转换、找到对应的哈希值后，要编写链表的遍历查找代码
* `unload`：和check函数思路类似，但是要清空遍历到的节点所使用的内存空间。

## Speller(Trie)

Trie版本的speller和哈希表版本的基本框架是类似的，区别在于单词存储的数据结构。在本练习中，使用的是课堂上讲过的Trie，就本题来说，Trie本质上是“27叉树”（参考二叉树）。


* `load`：值得注意的的是，Trie的节点并不存储单词字符本身，单词以一个一个字符的方式存储在"路径"上的。以及要注意判断，某一个节点是否表示一个单词的结束——把`is_word`设为真。此外还需要注意单词、字母大小写的转换。必要时可以编写适当的辅助函数。
* `size`：与哈希值的版本相同，可以直接换回一个统计变量。
* `check`：查找单词是否存在，就是在这个“树”(Trie)上，按照给定单词字母的提示，从根开始“游走”，如果走到最后发现无路可走，或者停留在了不该停留的位置上——（`is_word`设为假），那就意味着对应的单词拼写有误。
* `unload`：和check函数思路类似，不过这次是完整的遍历这课树（Trie），可以参考二叉树的[后序遍历](https://zh.wikipedia.org/wiki/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86#%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86(Post-Order_Traversal))算法。本算法同样有递回和迭代两种设计思路，递归算法相对来说编写比较简单，必要时也可以编写额外的辅助函数。

## 实用建议

* `speller.c`文件并不需要更改，不过在debug阶段，可以适当的加以改动。
* 自行编写规模更小的测试数据，以检测程序运行是否正确。